{
  "language": "Solidity",
  "sources": {
    "contracts/BNJICurve.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\ncontract BNJICurve is Ownable, Pausable{   \r\n\r\n  uint256 USDCscale = 10**6;  \r\n\r\n  uint256 curveFactor = 800000;\r\n\r\n  function calcPriceForTokenMint(\r\n    uint256 supply,    \r\n    uint256 tokensToMint) public view returns (uint256)\r\n  { \r\n    require(tokensToMint > 0, \"BNJICurve: Must mint more than 0 tokens\");  \r\n    \r\n    uint256 supplySquared = supply*supply;    \r\n\r\n    uint256 supplyAfterMint = supply + tokensToMint;    \r\n    uint256 supplyAfterMintSquared = supplyAfterMint * supplyAfterMint; \r\n\r\n    uint256 step1 = supplyAfterMintSquared - supplySquared; \r\n    \r\n    uint256 step2 = step1 * USDCscale;\r\n   \r\n    uint256 totalPriceForTokensMintingNowInUSDC6digits = step2 / curveFactor;  \r\n        \r\n    uint256 takeOffFactor = 10 ** 4;\r\n    \r\n    uint256 rest = totalPriceForTokensMintingNowInUSDC6digits % takeOffFactor;\r\n    \r\n    uint256 mintResultWithCentsroundedDown = totalPriceForTokensMintingNowInUSDC6digits - rest;\r\n    \r\n    // returning price for specified token amount\r\n    return mintResultWithCentsroundedDown;        \r\n  }\r\n\r\n  function calcReturnForTokenBurn(\r\n    uint256 supply,    \r\n    uint256 tokensToBurn) public view returns (uint256)\r\n  {\r\n    // validate input\r\n    \r\n    require(supply > 0 && tokensToBurn > 0 && supply >= tokensToBurn, \"BNJICurve: Sending args must be larger than 0\");   \r\n    \r\n    uint256 supplyAfterBurn = supply - tokensToBurn; \r\n\r\n    uint256 supplySquared = supply * supply; \r\n    uint256 supplyAfterBurnSquared = supplyAfterBurn * supplyAfterBurn;\r\n    \r\n    uint256 step1 = supplySquared - supplyAfterBurnSquared;    \r\n   \r\n    uint256 step2 = step1 * USDCscale ;\r\n    \r\n    uint256 returnForTokenBurnInUSDC6digits = step2/ 800000 ;\r\n    \r\n    uint256 takeOffFactor = 10 ** 4;\r\n   \r\n    uint256 rest = returnForTokenBurnInUSDC6digits % takeOffFactor;\r\n   \r\n    uint256 burnResultWithCentsroundedDown = returnForTokenBurnInUSDC6digits - rest;    \r\n\r\n    return burnResultWithCentsroundedDown;    \r\n  }\r\n  \r\n  // function for owner to withdraw any ERC20 token that has accumulated\r\n  function updateCurveFactor (uint256 newCurveFactor) public onlyOwner {\r\n    curveFactor = newCurveFactor;\r\n  }\r\n\r\n  // function for owner to withdraw any ERC20 token that has accumulated\r\n  function withdrawERC20 (address ERC20ContractAddress, uint256 amount) public onlyOwner {\r\n    IERC20 ERC20Instance = IERC20(ERC20ContractAddress);        \r\n    ERC20Instance.transfer(msg.sender, amount);         \r\n  }\r\n\r\n  // pausing funcionality from OpenZeppelin's Pausable\r\n  function pause() public onlyOwner {\r\n    _pause();\r\n  }\r\n\r\n  // unpausing funcionality from OpenZeppelin's Pausable\r\n  function unpause() public onlyOwner {\r\n    _unpause();\r\n  }\r\n\r\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MumbaiBenjamins.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"./BNJICurve.sol\";\r\nimport \"./ILendingPool.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract MumbaiBenjamins is ERC20, BNJICurve, ReentrancyGuard {   // <==== changed_ for Mumbai testnet\r\n  using SafeMath for uint256;\r\n \r\n  address public addressOfThisContract;\r\n\r\n  address private feeReceiver; \r\n  address private accumulatedReceiver;   \r\n\r\n  address[] private stakers;\r\n  address[] private internalAddresses;\r\n\r\n  mapping (address => uint256) private ownedBenjamins;\r\n  mapping (address => uint256) private internalBenjamins;\r\n  mapping (address => uint256) private totalStakedByUser;\r\n  mapping (address => bool) private isOnStakingList;\r\n  mapping (address => bool) private isOnInternalList;\r\n  mapping (address => Stake[]) private usersStakingPositions;\r\n  mapping (address => Stake[]) private internalStakingPositions;  \r\n\r\n  struct Stake {\r\n    address stakingAddress;\r\n    uint256 stakeID;\r\n    uint256 tokenAmount;    \r\n    uint256 stakeCreatedTimestamp; \r\n    bool unstaked;\r\n  }\r\n\r\n  uint8 private amountDecimals;\r\n  uint256 largestUint = type(uint256).max;\r\n\r\n  uint256 centsScale4digits = 10000;\r\n  uint256 dollarScale6dec = 1000000;\r\n\r\n  uint256 stakingPeriodInSeconds = 1; // 86400; <===== XXXXX, changed_ only for testing\r\n\r\n  uint256 tier_0_feeMod = 100;\r\n  uint256 tier_1_feeMod = 95;\r\n  uint256 tier_2_feeMod = 85;\r\n  uint256 tier_3_feeMod = 70;\r\n  uint256 tier_4_feeMod = 50;\r\n  uint256 tier_5_feeMod = 25;   \r\n\r\n  ILendingPool public polygonLendingPool;\r\n  IERC20 public polygonUSDC;\r\n  IERC20 public polygonAMUSDC;\r\n\r\n  event SpecifiedMintEvent (address sender, uint256 tokenAmount, uint256 priceForMintingIn6dec);  \r\n\r\n  event SpecifiedBurnEvent (address sender, uint256 tokenAmount, uint256 returnForBurning);  \r\n\r\n  event LendingPoolDeposit (uint256 amount);\r\n  \r\n  event LendingPoolWithdrawal (uint256 amount);\r\n\r\n  constructor(address feeReceiverAddress) ERC20(\"MumbaiBenjamins\", \"MumBenj\") {     // <==== changed_ for Mumbai testnet\r\n    addressOfThisContract = address(this);\r\n    feeReceiver = feeReceiverAddress;\r\n    amountDecimals = 0;\r\n    //polygonUSDC = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);               <==== changed_ for Mumbai testnet\r\n    //polygonAMUSDC = IERC20(0x1a13F4Ca1d028320A707D99520AbFefca3998b7F);             <==== changed_ for Mumbai testnet\r\n    //polygonLendingPool = ILendingPool(0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf);  <==== changed_ for Mumbai testnet       \r\n    \r\n    polygonUSDC = IERC20(0x2058A9D7613eEE744279e3856Ef0eAda5FCbaA7e);               // <==== changed_ for Mumbai testnet\r\n    polygonAMUSDC = IERC20(0x2271e3Fef9e15046d09E1d78a8FF038c691E9Cf9);             // <==== changed_ for Mumbai testnet\r\n    polygonLendingPool = ILendingPool(0x9198F13B08E299d85E096929fA9781A1E3d5d827);  // <==== changed_ for Mumbai testnet   \r\n\r\n    approveLendingPool(largestUint);    \r\n    pause();\r\n  }\r\n\r\n  receive() external payable {   \r\n  }\r\n\r\n\r\n  function approveLendingPool (uint256 amountToApprove) public onlyOwner {   \r\n    polygonUSDC.approve(address(polygonLendingPool), amountToApprove);       \r\n  }\r\n\r\n  \r\n  function decimals() public view override returns (uint8) {\r\n    return amountDecimals;\r\n  }\r\n  \r\n  function findUsersLevelFeeModifier (address user) private view returns (uint256 usersFee) {\r\n\r\n    uint256 usersStakedBalance = checkStakedBenjamins(user);\r\n    \r\n    if (usersStakedBalance < 20) {\r\n      return tier_0_feeMod;\r\n    }\r\n    else if (usersStakedBalance >= 20 && usersStakedBalance < 40 ) {\r\n      return tier_1_feeMod;\r\n    }    \r\n    else if (usersStakedBalance >= 40 && usersStakedBalance < 60) {\r\n      return tier_2_feeMod;\r\n    }\r\n    else if (usersStakedBalance >= 60 && usersStakedBalance < 80) {\r\n      return tier_3_feeMod;\r\n    }  \r\n    else if (usersStakedBalance >= 80 && usersStakedBalance < 100) {\r\n      return tier_4_feeMod;\r\n    } \r\n    else if (usersStakedBalance >= 100 ) {\r\n      return tier_5_feeMod;\r\n    } \r\n    \r\n  }\r\n\r\n  function getUsersActiveAndBurnableStakes (address userToCheck) public view returns (Stake[] memory stakeArray){    \r\n\r\n    uint256 timestampNow = uint256(block.timestamp);\r\n\r\n    uint256 nrOfActiveBurnableStakes;\r\n\r\n    Stake[] memory usersStakeArray = usersStakingPositions[userToCheck];\r\n\r\n    for (uint256 index = 0; index < usersStakeArray.length; index++) {       \r\n                           \r\n      uint256 unlockTimeStamp = usersStakeArray[index].stakeCreatedTimestamp + stakingPeriodInSeconds;  \r\n      \r\n      // each time an active and burnable stake is found, nrOfActiveBurnableStakes is increased by 1\r\n      if (usersStakeArray[index].unstaked == false && unlockTimeStamp <= timestampNow ) {\r\n        nrOfActiveBurnableStakes++;\r\n      }    \r\n\r\n    }\r\n\r\n    if (nrOfActiveBurnableStakes == 0){\r\n      return new Stake[](0);\r\n    }\r\n\r\n    else {\r\n      // 'activeBurnableStakes' array with hardcoded length, defined by active stakes found above\r\n      Stake[] memory activeBurnableStakes = new Stake[](nrOfActiveBurnableStakes);      \r\n\r\n      // index position in activeBurnableStakes array\r\n      uint256 newIndex = 0 ;\r\n\r\n      for (uint256 k = 0; k < activeBurnableStakes.length; k++) {\r\n        \r\n        // each time an active stake is found, its details are put into the next position in the 'activeBurnableStakes' array\r\n        if (usersStakeArray[k].unstaked == false) {\r\n          activeBurnableStakes[newIndex].stakingAddress = usersStakeArray[newIndex].stakingAddress;\r\n          activeBurnableStakes[newIndex].stakeID = usersStakeArray[newIndex].stakeID;\r\n          activeBurnableStakes[newIndex].tokenAmount = usersStakeArray[newIndex].tokenAmount;\r\n          activeBurnableStakes[newIndex].stakeCreatedTimestamp = usersStakeArray[newIndex].stakeCreatedTimestamp;\r\n          activeBurnableStakes[newIndex].unstaked = usersStakeArray[newIndex].unstaked;\r\n          newIndex++;\r\n        }         \r\n\r\n      }\r\n      // returning activeBurnableStakes array\r\n      return activeBurnableStakes; \r\n\r\n    } \r\n    \r\n  } \r\n\r\n  \r\n\r\n  /*\r\n  function specifiedMint( uint256 tokenAmountToMint) public whenNotPaused {        \r\n    specifiedAmountMint(tokenAmountToMint);\r\n  }\r\n  */\r\n\r\n  function buyLevels(uint256 amountOfLevels) public whenNotPaused {\r\n    specifiedAmountMint(amountOfLevels * 20);\r\n  }\r\n\r\n  function specifiedAmountMint(uint256 amount) internal whenNotPaused nonReentrant returns (uint256) {   \r\n    \r\n    require((amount % 20 == 0), \"BNJ, specifiedAmountMint: Amount must be divisible by 20\");       \r\n    \r\n    uint256 priceForMintingIn6dec = calcSpecMintReturn(amount);\r\n    \r\n    uint256 usersFeeModifier = findUsersLevelFeeModifier( msg.sender ); \r\n\r\n    uint256 feeIn6dec = ((priceForMintingIn6dec * usersFeeModifier) /100) /100;\r\n    \r\n    uint256 roundThisDown = feeIn6dec % (10**4);\r\n    \r\n    uint256 feeRoundedDownIn6dec = feeIn6dec - roundThisDown;\r\n    \r\n    uint256 endPriceIn6dec = priceForMintingIn6dec + feeRoundedDownIn6dec;\r\n    \r\n    uint256 polygonUSDCbalanceIn6dec = polygonUSDC.balanceOf( msg.sender ) ;\r\n    \r\n    uint256 USDCAllowancein6dec = polygonUSDC.allowance(msg.sender, addressOfThisContract); \r\n    \r\n    require (endPriceIn6dec <= polygonUSDCbalanceIn6dec, \"BNJ, specifiedAmountMint: Not enough USDC\"); \r\n    require (endPriceIn6dec <= USDCAllowancein6dec, \"BNJ, specifiedAmountMint: Not enough allowance in USDC for payment\" );\r\n    require (priceForMintingIn6dec >= 5000000, \"BNJ, specifiedAmountMint: Minimum minting value of $5 USDC\" );\r\n    \r\n    polygonUSDC.transferFrom(msg.sender, feeReceiver, feeRoundedDownIn6dec);   \r\n\r\n    polygonUSDC.transferFrom(msg.sender, addressOfThisContract, priceForMintingIn6dec);  \r\n\r\n    depositIntoLendingPool(priceForMintingIn6dec);      \r\n  \r\n    // minting to Benjamins contract itself\r\n    _mint(addressOfThisContract, amount);\r\n    emit SpecifiedMintEvent(msg.sender, amount, priceForMintingIn6dec);\r\n\r\n    // this is the user's balance of tokens\r\n    ownedBenjamins[msg.sender] += amount;\r\n\r\n    uint256 amountOfLevelsToBuy = amount / 20;\r\n\r\n    for (uint256 index = 0; index < amountOfLevelsToBuy; index++) {\r\n      stakeTokens(msg.sender, 20);\r\n    }     \r\n\r\n    return priceForMintingIn6dec;   \r\n  }  \r\n\r\n  function calcSpecMintReturn(uint256 amount) public view returns (uint256 mintPrice) {\r\n    return calcPriceForTokenMint(totalSupply(), amount); \r\n  }    \r\n\r\n  /*\r\n  function specifiedBurn( uint256 tokenAmountToBurn) public payable whenNotPaused {    \r\n    specifiedAmountBurn(tokenAmountToBurn);\r\n  }\r\n  */\r\n\r\n  function sellLevels(uint256 amountOfLevels) public whenNotPaused {\r\n    specifiedAmountBurn(amountOfLevels * 20);\r\n  }\r\n\r\n  function specifiedAmountBurn(uint256 amount) internal whenNotPaused nonReentrant returns (uint256) {    \r\n\r\n    require((amount % 20) == 0, \"BNJ, specifiedAmountMint: Amount must be divisible by 20\");   \r\n\r\n    uint256 tokenBalance = checkStakedBenjamins(msg.sender);    \r\n     \r\n    require(amount > 0, \"Amount to burn must be more than zero.\");  \r\n    require(tokenBalance >= amount, \"Users tokenBalance must be equal to or more than amount to burn.\");             \r\n    \r\n    uint256 returnForBurningIn6dec = calcSpecBurnReturn(amount);\r\n    \r\n    require (returnForBurningIn6dec >= 5000000, \"BNJ, specifiedAmountBurn: Minimum burning value is $5 USDC\" );\r\n\r\n    uint256 usersFeeModifier = findUsersLevelFeeModifier( msg.sender );\r\n\r\n    uint256 feeIn6dec = ((returnForBurningIn6dec * usersFeeModifier) /100) / 100;   \r\n    \r\n    uint256 roundThisDown = feeIn6dec % (10**4);\r\n    \r\n    uint256 feeRoundedDown = feeIn6dec - roundThisDown;\r\n   \r\n    uint256 endReturnIn6dec = returnForBurningIn6dec - feeRoundedDown;      \r\n\r\n    uint256 amountOfLevelsToSell = amount / 20;\r\n\r\n    for (uint256 index = 0; index < amountOfLevelsToSell; index++) {\r\n      unstakeTokens(msg.sender, 20);\r\n    }   \r\n\r\n    // this is the user's balance of tokens\r\n    ownedBenjamins[msg.sender] -= amount;\r\n\r\n    _burn(addressOfThisContract, amount);      \r\n    emit SpecifiedBurnEvent(msg.sender, amount, returnForBurningIn6dec);      \r\n\r\n\r\n    withdrawFromLendingPool(returnForBurningIn6dec); \r\n\r\n    polygonUSDC.transfer(feeReceiver, feeRoundedDown);\r\n    polygonUSDC.transfer(msg.sender, endReturnIn6dec);     \r\n    \r\n    \r\n\r\n    return returnForBurningIn6dec;   \r\n  }\r\n\r\n  function calcSpecBurnReturn(uint256 amount) public view returns (uint256 burnReturn) {    \r\n    //console.log(\"BNJ, calcSpecBurnReturn, totalsupply:\", totalSupply() );\r\n    //console.log(\"BNJ, calcSpecBurnReturn, amount:\", amount );\r\n    return calcReturnForTokenBurn(totalSupply(), amount); \r\n  }      \r\n\r\n  function stakeTokens(address stakingUserAddress, uint256 amountOfTokensToStake) private {\r\n    uint256 tokensOwned = checkOwnedBenjamins( stakingUserAddress ) ;    \r\n\r\n    require (amountOfTokensToStake <= tokensOwned, 'BNJ, stakeTokens: Not enough tokens'); \r\n\r\n    if (!isOnStakingList[stakingUserAddress]) {\r\n      stakers.push(stakingUserAddress);\r\n      isOnStakingList[stakingUserAddress] = true;\r\n    }\r\n\r\n    uint256 stakeID = usersStakingPositions[stakingUserAddress].length;\r\n\r\n    Stake memory newStake = Stake({ \r\n      stakingAddress: address(stakingUserAddress),\r\n      stakeID: uint256(stakeID),\r\n      tokenAmount: uint256(amountOfTokensToStake),      \r\n      stakeCreatedTimestamp: uint256(block.timestamp),\r\n      unstaked: false       \r\n    });        \r\n\r\n    usersStakingPositions[stakingUserAddress].push(newStake);\r\n\r\n    totalStakedByUser[stakingUserAddress] += amountOfTokensToStake;\r\n  }\r\n\r\n  function unstakeTokens(address stakingUserAddress, uint256 amountOfTokensToUnstake) private {\r\n\r\n    uint256 tokensStaked = checkStakedBenjamins( stakingUserAddress ) ;    \r\n\r\n    require (amountOfTokensToUnstake <= tokensStaked, 'BNJ, unstakeTokens: Not enough tokens'); \r\n   \r\n    Stake[] memory usersActiveBurnableStakess = getUsersActiveAndBurnableStakes(stakingUserAddress);\r\n\r\n    require (usersActiveBurnableStakess.length > 0, 'BNJ, unstakeTokens: No burnable staking positions found. Consider time since staking.');\r\n\r\n    uint256 newestActiveStake = usersActiveBurnableStakess.length - 1;\r\n\r\n    uint256 stakeIDtoUnstake = usersActiveBurnableStakess[newestActiveStake].stakeID;    \r\n\r\n    for (uint256 unStIndex = 0; unStIndex < usersStakingPositions[stakingUserAddress].length; unStIndex++) {\r\n      if (usersStakingPositions[stakingUserAddress][unStIndex].stakeID == stakeIDtoUnstake ) {\r\n        usersStakingPositions[stakingUserAddress][unStIndex].unstaked = true;\r\n      }\r\n    }    \r\n\r\n    totalStakedByUser[stakingUserAddress] -= amountOfTokensToUnstake;\r\n  }\r\n\r\n  function checkOwnedBenjamins(address userToCheck) private view returns (uint256 usersOwnedBNJIs){\r\n    return ownedBenjamins[userToCheck];\r\n  }\r\n\r\n  function showInternalAddresses() public view onlyOwner returns (address[] memory) {\r\n    return internalAddresses;  \r\n  }\r\n\r\n function showStakersAddresses() public view onlyOwner returns (address[] memory) {\r\n    return stakers;  \r\n  }\r\n  \r\n  \r\n  function checkStakedBenjamins(address userToCheck) public view returns (uint256 usersStakedBNJIs){   // XXXXX <=======changed_ this only for testing, should be private visibility\r\n    uint256 usersTotalStake = totalStakedByUser[userToCheck];\r\n   \r\n    return usersTotalStake;\r\n  }   \r\n\r\n  function depositIntoLendingPool(uint256 amount) private {    \r\n\t\tpolygonLendingPool.deposit(address(polygonUSDC), amount, addressOfThisContract, 0);    \r\n    emit LendingPoolDeposit(amount);\r\n\t}\r\n\r\n\tfunction withdrawFromLendingPool(uint256 amount) private whenNotPaused {\r\n\t\tpolygonLendingPool.withdraw(address(polygonUSDC), amount, addressOfThisContract);\r\n    emit LendingPoolWithdrawal(amount);\r\n\t}\r\n \r\n  \r\n  function internalMint(uint256 amount, address holderOfInternalMint) public onlyOwner returns (uint256) {\r\n   \r\n    if (!isOnInternalList[holderOfInternalMint]) {\r\n      internalAddresses.push(holderOfInternalMint);\r\n      isOnInternalList[holderOfInternalMint] = true;\r\n    }\r\n    \r\n    require(amount > 0, \"BNJ, internalMint: Amount must be more than zero.\");        \r\n    require(amount % 20 == 0, \"BNJ, internalMint: Amount must be divisible by 20\");   \r\n    \r\n    uint256 priceForMintingIn6dec = calcSpecMintReturn(amount);    \r\n\r\n    uint256 polygonUSDCbalanceIn6dec = polygonUSDC.balanceOf( msg.sender ) ;   \r\n\r\n    uint256 USDCAllowancein6dec = polygonUSDC.allowance(msg.sender, addressOfThisContract);     \r\n    \r\n    require (priceForMintingIn6dec <= polygonUSDCbalanceIn6dec, \"BNJ, internalMint: Not enough USDC\"); \r\n    require (priceForMintingIn6dec <= USDCAllowancein6dec, \"BNJ, internalMint: Not enough allowance in USDC for payment\" );\r\n    require (priceForMintingIn6dec >= 5000000, \"BNJ, internalMint: Minimum minting value of $5 USDC\" );      \r\n\r\n    polygonUSDC.transferFrom(msg.sender, addressOfThisContract, priceForMintingIn6dec);\r\n    depositIntoLendingPool(priceForMintingIn6dec);    \r\n  \r\n    // minting to Benjamins contract itself\r\n    _mint(addressOfThisContract, amount);\r\n    emit SpecifiedMintEvent(msg.sender, amount, priceForMintingIn6dec);\r\n\r\n    // this is the user's balance of tokens\r\n    internalBenjamins[holderOfInternalMint] += amount;    \r\n\r\n    return priceForMintingIn6dec; \r\n  }\r\n\r\n  function internalBurn(uint256 amount) public whenNotPaused nonReentrant returns (uint256) {   \r\n\r\n    require(amount % 20 == 0, \"BNJ, internalBurn: Amount must be divisible by 20\");   \r\n\r\n    uint256 tokenBalance = internalBenjamins[msg.sender];  \r\n     \r\n    require(amount > 0, \"Amount to burn must be more than zero.\");  \r\n    require(tokenBalance >= amount, \"Users tokenBalance must be equal to or more than amount to burn.\");             \r\n    \r\n    uint256 returnForBurningIn6dec = calcSpecBurnReturn(amount);    \r\n\r\n    require (returnForBurningIn6dec >= 5000000, \"BNJ, internalBurn: Minimum burning value is $5 USDC\" );    \r\n\r\n    // this is the user's balance of tokens\r\n    internalBenjamins[msg.sender] -= amount;\r\n\r\n    _burn(addressOfThisContract, amount);      \r\n    emit SpecifiedBurnEvent(msg.sender, amount, returnForBurningIn6dec);  \r\n\r\n    withdrawFromLendingPool(returnForBurningIn6dec); \r\n   \r\n    polygonUSDC.transfer(msg.sender, returnForBurningIn6dec);  \r\n\r\n    return returnForBurningIn6dec;   \r\n  }\r\n\r\n  function showAllUsersStakes(address userToCheck) public view onlyOwner returns (Stake[] memory stakeArray) { \r\n    return usersStakingPositions[userToCheck];\r\n  }\r\n\r\n  function showInternalBenjamins (address userToCheck) public view onlyOwner returns (uint256) {   \r\n    return internalBenjamins[userToCheck];\r\n  }\r\n\r\n  function getInternalActiveStakes(address userToCheck) public view onlyOwner returns (Stake[] memory stakeArray){\r\n\r\n    uint256 nrOfActiveStakes;\r\n\r\n    Stake[] memory usersStakeArray = internalStakingPositions[userToCheck];\r\n\r\n    for (uint256 index = 0; index < usersStakeArray.length; index++) { \r\n\r\n      // each time an active stake is found, nrOfActiveStakes is increased by 1\r\n      if (usersStakeArray[index].unstaked == false) {\r\n        nrOfActiveStakes++;\r\n      }     \r\n    }\r\n\r\n    if (nrOfActiveStakes == 0){\r\n      return new Stake[](0);\r\n    }\r\n\r\n    else {\r\n      // 'activeStakes' array with hardcoded length, defined by active stakes found above\r\n      Stake[] memory activeStakes = new Stake[](nrOfActiveStakes);      \r\n\r\n      // index position in activeStakes array\r\n      uint256 newIndex = 0 ;\r\n\r\n      for (uint256 k = 0; k < activeStakes.length; k++) {\r\n        \r\n        // each time an active stake is found, its details are put into the next position in the 'activeStakes' array\r\n        if (usersStakeArray[k].unstaked == false) {\r\n          activeStakes[newIndex].stakingAddress = usersStakeArray[newIndex].stakingAddress;\r\n          activeStakes[newIndex].stakeID = usersStakeArray[newIndex].stakeID;          \r\n          activeStakes[newIndex].tokenAmount = usersStakeArray[newIndex].tokenAmount;\r\n          activeStakes[newIndex].stakeCreatedTimestamp = usersStakeArray[newIndex].stakeCreatedTimestamp;\r\n          activeStakes[newIndex].unstaked = usersStakeArray[newIndex].unstaked;\r\n          newIndex++;\r\n        }         \r\n\r\n      }\r\n      // returning activeStakes array\r\n      return activeStakes; \r\n\r\n    } \r\n    \r\n  } \r\n\r\n  function calcAccumulated() public view onlyOwner returns (uint256 accumulatedAmount) {\r\n    uint256 allTokensValue = calcAllTokensValue();\r\n    uint256 allTokensValueBuffered = (allTokensValue * 97) / 100;\r\n\r\n    uint256 allAMUSDC = polygonAMUSDC.balanceOf(addressOfThisContract);\r\n\r\n    uint256 accumulated = allTokensValueBuffered - allAMUSDC;\r\n    return accumulated;\r\n\r\n  }   \r\n\r\n  function withdrawAccumulated(uint256 amount) public onlyOwner {\r\n    polygonAMUSDC.transfer(accumulatedReceiver, amount);\r\n  } \r\n\r\n  function depositUSDCBuffer (uint256 amount) public onlyOwner {\r\n    polygonLendingPool.deposit(address(polygonUSDC), amount, addressOfThisContract, 0);    \r\n    emit LendingPoolDeposit(amount);\r\n  } \r\n\r\n  function calcAllTokensValue() public view onlyOwner returns (uint256 allTokensReturn) {\r\n    return calcReturnForTokenBurn(totalSupply(), totalSupply()); \r\n  }\r\n\r\n  function updateStakingPeriodInSeconds (uint256 newstakingPeriodInSeconds) public onlyOwner {\r\n    stakingPeriodInSeconds = newstakingPeriodInSeconds;\r\n  }  \r\n\r\n  function updateFeeReceiver(address newAddress) public onlyOwner {\r\n    require(newAddress != address(0), \"updateFeeReceiver: newAddress cannot be the zero address\");\r\n    feeReceiver = newAddress;\r\n  }\r\n\r\n  function updateAccumulatedReceiver(address newAddress) public onlyOwner {\r\n    require(newAddress != address(0), \"updateAccumulatedReceiver: newAddress cannot be the zero address\");\r\n    accumulatedReceiver = newAddress;\r\n  }  \r\n\r\n  function updatePolygonUSDC(address newAddress) public onlyOwner {\r\n    require(newAddress != address(0), \"updatePolygonUSDC: newAddress cannot be the zero address\");\r\n    polygonUSDC = IERC20(newAddress);\r\n  }\r\n\r\n  function updatePolygonAMUSDCC(address newAddress) public onlyOwner {\r\n    require(newAddress != address(0), \"updatePolygonAMUSDCC: newAddress cannot be the zero address\");\r\n    polygonAMUSDC = IERC20(newAddress);\r\n  }\r\n\r\n  function updatePolygonLendingPool(address newAddress) public onlyOwner {\r\n    require(newAddress != address(0), \"updatePolygonLendingPool: newAddress cannot be the zero address\");\r\n    polygonLendingPool = ILendingPool(newAddress);\r\n  }\r\n    \r\n  function updateTier0feeMod (uint256 newtier0feeMod) public onlyOwner {\r\n    tier_0_feeMod = newtier0feeMod;\r\n  }\r\n\r\n  function updateTier1feeMod (uint256 newtier1feeMod) public onlyOwner {\r\n    tier_1_feeMod = newtier1feeMod;\r\n  }\r\n\r\n  function updateTier2feeMod (uint256 newtier2feeMod) public onlyOwner {\r\n    tier_2_feeMod = newtier2feeMod;\r\n  }\r\n\r\n  function updateTier3feeMod (uint256 newtier3feeMod) public onlyOwner {\r\n    tier_3_feeMod = newtier3feeMod;\r\n  }\r\n\r\n  function updateTier4feeMod (uint256 newtier4feeMod) public onlyOwner {\r\n    tier_4_feeMod = newtier4feeMod;\r\n  } \r\n\r\n  function updateTier5feeMod (uint256 newtier4feeMod) public onlyOwner {\r\n    tier_5_feeMod = newtier4feeMod;\r\n  }   \r\n\r\n}\r\n"
    },
    "contracts/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.8.0;\r\n\r\nlibrary DataTypes {\r\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    //tokens addresses\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint8 id;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: Reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60-63: reserved\r\n    //bit 64-79: reserve factor\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    uint256 data;\r\n  }\r\n\r\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n\r\ninterface ILendingPool {\r\n\t/**\r\n\t * @dev Emitted on deposit()\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param user The address initiating the deposit\r\n\t * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n\t * @param amount The amount deposited\r\n\t * @param referral The referral code used\r\n\t **/\r\n\tevent Deposit(\r\n\t\taddress indexed reserve,\r\n\t\taddress user,\r\n\t\taddress indexed onBehalfOf,\r\n\t\tuint256 amount,\r\n\t\tuint16 indexed referral\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on withdraw()\r\n\t * @param reserve The address of the underlyng asset being withdrawn\r\n\t * @param user The address initiating the withdrawal, owner of aTokens\r\n\t * @param to Address that will receive the underlying\r\n\t * @param amount The amount to be withdrawn\r\n\t **/\r\n\tevent Withdraw(\r\n\t\taddress indexed reserve,\r\n\t\taddress indexed user,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n\t * @param reserve The address of the underlying asset being borrowed\r\n\t * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n\t * initiator of the transaction on flashLoan()\r\n\t * @param onBehalfOf The address that will be getting the debt\r\n\t * @param amount The amount borrowed out\r\n\t * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n\t * @param borrowRate The numeric rate at which the user has borrowed\r\n\t * @param referral The referral code used\r\n\t **/\r\n\tevent Borrow(\r\n\t\taddress indexed reserve,\r\n\t\taddress user,\r\n\t\taddress indexed onBehalfOf,\r\n\t\tuint256 amount,\r\n\t\tuint256 borrowRateMode,\r\n\t\tuint256 borrowRate,\r\n\t\tuint16 indexed referral\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on repay()\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param user The beneficiary of the repayment, getting his debt reduced\r\n\t * @param repayer The address of the user initiating the repay(), providing the funds\r\n\t * @param amount The amount repaid\r\n\t **/\r\n\tevent Repay(\r\n\t\taddress indexed reserve,\r\n\t\taddress indexed user,\r\n\t\taddress indexed repayer,\r\n\t\tuint256 amount\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on swapBorrowRateMode()\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param user The address of the user swapping his rate mode\r\n\t * @param rateMode The rate mode that the user wants to swap to\r\n\t **/\r\n\tevent Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n\t/**\r\n\t * @dev Emitted on setUserUseReserveAsCollateral()\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param user The address of the user enabling the usage as collateral\r\n\t **/\r\n\tevent ReserveUsedAsCollateralEnabled(\r\n\t\taddress indexed reserve,\r\n\t\taddress indexed user\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on setUserUseReserveAsCollateral()\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param user The address of the user enabling the usage as collateral\r\n\t **/\r\n\tevent ReserveUsedAsCollateralDisabled(\r\n\t\taddress indexed reserve,\r\n\t\taddress indexed user\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on rebalanceStableBorrowRate()\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param user The address of the user for which the rebalance has been executed\r\n\t **/\r\n\tevent RebalanceStableBorrowRate(\r\n\t\taddress indexed reserve,\r\n\t\taddress indexed user\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted on flashLoan()\r\n\t * @param target The address of the flash loan receiver contract\r\n\t * @param initiator The address initiating the flash loan\r\n\t * @param asset The address of the asset being flash borrowed\r\n\t * @param amount The amount flash borrowed\r\n\t * @param premium The fee flash borrowed\r\n\t * @param referralCode The referral code used\r\n\t **/\r\n\tevent FlashLoan(\r\n\t\taddress indexed target,\r\n\t\taddress indexed initiator,\r\n\t\taddress indexed asset,\r\n\t\tuint256 amount,\r\n\t\tuint256 premium,\r\n\t\tuint16 referralCode\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted when the pause is triggered.\r\n\t */\r\n\tevent Paused();\r\n\r\n\t/**\r\n\t * @dev Emitted when the pause is lifted.\r\n\t */\r\n\tevent Unpaused();\r\n\r\n\t/**\r\n\t * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n\t * LendingPoolCollateral manager using a DELEGATECALL\r\n\t * This allows to have the events in the generated ABI for LendingPool.\r\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n\t * @param user The address of the borrower getting liquidated\r\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n\t * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n\t * @param liquidator The address of the liquidator\r\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n\t * to receive the underlying collateral asset directly\r\n\t **/\r\n\tevent LiquidationCall(\r\n\t\taddress indexed collateralAsset,\r\n\t\taddress indexed debtAsset,\r\n\t\taddress indexed user,\r\n\t\tuint256 debtToCover,\r\n\t\tuint256 liquidatedCollateralAmount,\r\n\t\taddress liquidator,\r\n\t\tbool receiveAToken\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n\t * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n\t * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n\t * gets added to the LendingPool ABI\r\n\t * @param reserve The address of the underlying asset of the reserve\r\n\t * @param liquidityRate The new liquidity rate\r\n\t * @param stableBorrowRate The new stable borrow rate\r\n\t * @param variableBorrowRate The new variable borrow rate\r\n\t * @param liquidityIndex The new liquidity index\r\n\t * @param variableBorrowIndex The new variable borrow index\r\n\t **/\r\n\tevent ReserveDataUpdated(\r\n\t\taddress indexed reserve,\r\n\t\tuint256 liquidityRate,\r\n\t\tuint256 stableBorrowRate,\r\n\t\tuint256 variableBorrowRate,\r\n\t\tuint256 liquidityIndex,\r\n\t\tuint256 variableBorrowIndex\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n\t * @param asset The address of the underlying asset to deposit\r\n\t * @param amount The amount to be deposited\r\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n\t *   is a different wallet\r\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n\t *   0 if the action is executed directly by the user, without any middle-man\r\n\t **/\r\n\tfunction deposit(\r\n\t\taddress asset,\r\n\t\tuint256 amount,\r\n\t\taddress onBehalfOf,\r\n\t\tuint16 referralCode\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n\t * @param asset The address of the underlying asset to withdraw\r\n\t * @param amount The underlying amount to be withdrawn\r\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\r\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n\t *   different wallet\r\n\t * @return The final amount withdrawn\r\n\t **/\r\n\tfunction withdraw(\r\n\t\taddress asset,\r\n\t\tuint256 amount,\r\n\t\taddress to\r\n\t) external returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n\t * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n\t * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n\t * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n\t *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n\t * @param asset The address of the underlying asset to borrow\r\n\t * @param amount The amount to be borrowed\r\n\t * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n\t *   0 if the action is executed directly by the user, without any middle-man\r\n\t * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n\t * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n\t * if he has been given credit delegation allowance\r\n\t **/\r\n\tfunction borrow(\r\n\t\taddress asset,\r\n\t\tuint256 amount,\r\n\t\tuint256 interestRateMode,\r\n\t\tuint16 referralCode,\r\n\t\taddress onBehalfOf\r\n\t) external;\r\n\r\n\t/**\r\n\t * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n\t * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n\t * @param asset The address of the borrowed underlying asset previously borrowed\r\n\t * @param amount The amount to repay\r\n\t * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n\t * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n\t * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n\t * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n\t * other borrower whose debt should be removed\r\n\t * @return The final amount repaid\r\n\t **/\r\n\tfunction repay(\r\n\t\taddress asset,\r\n\t\tuint256 amount,\r\n\t\tuint256 rateMode,\r\n\t\taddress onBehalfOf\r\n\t) external returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n\t * @param asset The address of the underlying asset borrowed\r\n\t * @param rateMode The rate mode that the user wants to swap to\r\n\t **/\r\n\tfunction swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n\t/**\r\n\t * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n\t * - Users can be rebalanced if the following conditions are satisfied:\r\n\t *     1. Usage ratio is above 95%\r\n\t *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n\t *        borrowed at a stable rate and depositors are not earning enough\r\n\t * @param asset The address of the underlying asset borrowed\r\n\t * @param user The address of the user to be rebalanced\r\n\t **/\r\n\tfunction rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n\t/**\r\n\t * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n\t * @param asset The address of the underlying asset deposited\r\n\t * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n\t **/\r\n\tfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n\t\texternal;\r\n\r\n\t/**\r\n\t * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n\t * @param user The address of the borrower getting liquidated\r\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n\t * to receive the underlying collateral asset directly\r\n\t **/\r\n\tfunction liquidationCall(\r\n\t\taddress collateralAsset,\r\n\t\taddress debtAsset,\r\n\t\taddress user,\r\n\t\tuint256 debtToCover,\r\n\t\tbool receiveAToken\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n\t * as long as the amount taken plus a fee is returned.\r\n\t * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n\t * For further details please visit https://developers.aave.com\r\n\t * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n\t * @param assets The addresses of the assets being flash-borrowed\r\n\t * @param amounts The amounts amounts being flash-borrowed\r\n\t * @param modes Types of the debt to open if the flash loan is not returned:\r\n\t *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n\t *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n\t *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n\t * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n\t * @param params Variadic packed params to pass to the receiver as extra information\r\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n\t *   0 if the action is executed directly by the user, without any middle-man\r\n\t **/\r\n\tfunction flashLoan(\r\n\t\taddress receiverAddress,\r\n\t\taddress[] calldata assets,\r\n\t\tuint256[] calldata amounts,\r\n\t\tuint256[] calldata modes,\r\n\t\taddress onBehalfOf,\r\n\t\tbytes calldata params,\r\n\t\tuint16 referralCode\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Returns the user account data across all the reserves\r\n\t * @param user The address of the user\r\n\t * @return totalCollateralETH the total collateral in ETH of the user\r\n\t * @return totalDebtETH the total debt in ETH of the user\r\n\t * @return availableBorrowsETH the borrowing power left of the user\r\n\t * @return currentLiquidationThreshold the liquidation threshold of the user\r\n\t * @return ltv the loan to value of the user\r\n\t * @return healthFactor the current health factor of the user\r\n\t **/\r\n\tfunction getUserAccountData(address user)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 totalCollateralETH,\r\n\t\t\tuint256 totalDebtETH,\r\n\t\t\tuint256 availableBorrowsETH,\r\n\t\t\tuint256 currentLiquidationThreshold,\r\n\t\t\tuint256 ltv,\r\n\t\t\tuint256 healthFactor\r\n\t\t);\r\n\r\n\tfunction initReserve(\r\n\t\taddress reserve,\r\n\t\taddress aTokenAddress,\r\n\t\taddress stableDebtAddress,\r\n\t\taddress variableDebtAddress,\r\n\t\taddress interestRateStrategyAddress\r\n\t) external;\r\n\r\n\tfunction setReserveInterestRateStrategyAddress(\r\n\t\taddress reserve,\r\n\t\taddress rateStrategyAddress\r\n\t) external;\r\n\r\n\tfunction setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n\t/**\r\n\t * @dev Returns the configuration of the reserve\r\n\t * @param asset The address of the underlying asset of the reserve\r\n\t * @return The configuration of the reserve\r\n\t **/\r\n\tfunction getConfiguration(address asset)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n\t/**\r\n\t * @dev Returns the configuration of the user across all the reserves\r\n\t * @param user The user address\r\n\t * @return The configuration of the user\r\n\t **/\r\n\tfunction getUserConfiguration(address user)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (DataTypes.UserConfigurationMap memory);\r\n\r\n\t/**\r\n\t * @dev Returns the normalized income normalized income of the reserve\r\n\t * @param asset The address of the underlying asset of the reserve\r\n\t * @return The reserve's normalized income\r\n\t */\r\n\tfunction getReserveNormalizedIncome(address asset)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the normalized variable debt per unit of asset\r\n\t * @param asset The address of the underlying asset of the reserve\r\n\t * @return The reserve normalized variable debt\r\n\t */\r\n\tfunction getReserveNormalizedVariableDebt(address asset)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the state and configuration of the reserve\r\n\t * @param asset The address of the underlying asset of the reserve\r\n\t * @return The state of the reserve\r\n\t **/\r\n\tfunction getReserveData(address asset)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (DataTypes.ReserveData memory);\r\n\r\n\tfunction finalizeTransfer(\r\n\t\taddress asset,\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount,\r\n\t\tuint256 balanceFromAfter,\r\n\t\tuint256 balanceToBefore\r\n\t) external;\r\n\r\n\tfunction getReservesList() external view returns (address[] memory);\r\n\r\n\tfunction getAddressesProvider()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (ILendingPoolAddressesProvider);\r\n\r\n\tfunction setPause(bool val) external;\r\n\r\n\tfunction paused() external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n\tevent MarketIdSet(string newMarketId);\r\n\tevent LendingPoolUpdated(address indexed newAddress);\r\n\tevent ConfigurationAdminUpdated(address indexed newAddress);\r\n\tevent EmergencyAdminUpdated(address indexed newAddress);\r\n\tevent LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n\tevent LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n\tevent PriceOracleUpdated(address indexed newAddress);\r\n\tevent LendingRateOracleUpdated(address indexed newAddress);\r\n\tevent ProxyCreated(bytes32 id, address indexed newAddress);\r\n\tevent AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n\tfunction getMarketId() external view returns (string memory);\r\n\r\n\tfunction setMarketId(string calldata marketId) external;\r\n\r\n\tfunction setAddress(bytes32 id, address newAddress) external;\r\n\r\n\tfunction setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n\tfunction getAddress(bytes32 id) external view returns (address);\r\n\r\n\tfunction getLendingPool() external view returns (address);\r\n\r\n\tfunction setLendingPoolImpl(address pool) external;\r\n\r\n\tfunction getLendingPoolConfigurator() external view returns (address);\r\n\r\n\tfunction setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n\tfunction getLendingPoolCollateralManager() external view returns (address);\r\n\r\n\tfunction setLendingPoolCollateralManager(address manager) external;\r\n\r\n\tfunction getPoolAdmin() external view returns (address);\r\n\r\n\tfunction setPoolAdmin(address admin) external;\r\n\r\n\tfunction getEmergencyAdmin() external view returns (address);\r\n\r\n\tfunction setEmergencyAdmin(address admin) external;\r\n\r\n\tfunction getPriceOracle() external view returns (address);\r\n\r\n\tfunction setPriceOracle(address priceOracle) external;\r\n\r\n\tfunction getLendingRateOracle() external view returns (address);\r\n\r\n\tfunction setLendingRateOracle(address lendingRateOracle) external;\r\n}"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}